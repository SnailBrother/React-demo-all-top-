在组件中使用主题
在任何组件中，你都可以这样使用主题：

javascript
import { useTheme } from '../../context';

const MyComponent = () => {
  const { theme, toggleTheme, changeTheme, isDark } = useTheme();
  
  return (
    <div>
      <p>当前主题: {theme}</p>
      <button onClick={toggleTheme}>切换主题</button>
      <button onClick={() => changeTheme('light')}>设为浅色</button>
      <button onClick={() => changeTheme('dark')}>设为深色</button>
    </div>
  );
};

但是现在有一个问题
1、我在登陆的时候，我想要点击登陆之后会获取用户名和邮箱，然后根据用户名和邮箱在主题中去寻找对应的主题，其中主题是要字段is_active BIT DEFAULT 1，然后把这个作为我当前应用的主题
2、SystemThemeSettings.js界面我要进去的时候先根据用户名和邮箱获取里面所有的主题，然后显示在界面右边，最后字段is_active BIT DEFAULT 1的作为当前的主题
3、应用其他主题的时候，我想要把用户名和邮箱里面其他的主题字段is_active BIT 设置为0，就是其他的不用，暂停

核心思路：
后端 API 调整 (假设):

GET /api/UserThemeSettings/active: 新增一个端点，根据用户 email 和 username 获取 is_active=1 的主题。
PUT /api/UserThemeSettings/setActive/{id}: 新增一个端点，将指定 id 的主题设为 is_active=1，并将该用户其他所有主题设为 is_active=0。
GET /api/UserThemeSettings: 修改此接口，使其返回用户的所有主题列表。
POST /api/UserThemeSettings: 创建新主题时，可以接收一个 is_active 字段。
PUT /api/UserThemeSettings/{id}: 更新主题内容。
前端代码修改:

ThemeContext.js: 将成为唯一的主题数据来源。它将负责获取所有主题、获取活动主题、应用主题以及调用API切换活动主题。不再使用 localStorage 存储自定义主题。
AuthContext.js: 登录后，不再自己获取和应用主题，而是通知 ThemeContext 重新加载数据。这使得责任更加单一。
SystemThemeSettings.js: 将从 ThemeContext 获取所有主题并展示。应用、编辑、删除主题的操作都将通过 ThemeContext 里的函数调用后端API。

主要变更摘要：
GET /api/UserThemeSettings/active (新)

专门用于获取当前用户的活动主题 (is_active = 1)。
前端在登录后或刷新页面时调用此接口来应用正确的主题。
GET /api/UserThemeSettings (修改)

现在它会返回一个用户的所有主题，无论 is_active 状态如何。
用于在“主题设置”页面填充“已保存的主题”列表。
POST /api/UserThemeSettings (修改)

现在只负责创建新主题，默认 is_active 为 0。激活操作由下面的 setActive 接口负责。
PUT /api/UserThemeSettings/:id (修改)

现在只负责更新一个主题的具体颜色、字体等内容，不会影响其 is_active 状态。
PUT /api/UserThemeSettings/setActive/:id (新)

这是最重要的修改。它是一个原子操作，用于“应用”一个主题。
在一个数据库事务中完成两步操作：
把该用户的所有主题设置为 is_active = 0。
把 ID 为 :id 的这个主题设置为 is_active = 1。
这确保了任何时候一个用户都只有一个活动主题。
DELETE /api/UserThemeSettings/:id (修改)

从软删除（更新 is_active）改为了硬删除（DELETE FROM），直接从数据库中移除记录。这更符合前端UI的预期。
这些修改使你的后端 API 变得清晰、符合 RESTful 规范，并能完美支持你之前已经修改好的前端逻辑。

获取逻辑错误：GET /api/UserThemeSettings/all 接口错误地只查询 is_active = 1 的主题，它应该返回该用户的所有主题。
激活逻辑不完整：POST 和 PUT 接口在创建或更新主题时，只是简单地将当前主题的 is_active 设为 1，但没有将该用户的其他主题设为 0。这会导致数据库中出现多个 is_active = 1 的记录，破坏了“只有一个活动主题”的规则。
删除逻辑：你使用了软删除（设置 is_active = 0），这在功能上可以，但硬删除（DELETE）更符合前端“删除”操作的直观感受。我将提供一个真正的删除接口。
接口冗余：你创建的 deactivate-all 和 activate 接口需要前端进行两次调用才能完成一次“应用主题”的操作，这不仅效率低，而且不是原子操作（如果在两次调用之间发生错误，数据状态会不一致）。最好的方法是创建一个单一的、原子化的接口来处理激活逻辑。